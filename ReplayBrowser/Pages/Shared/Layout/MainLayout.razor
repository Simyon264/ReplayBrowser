@using Microsoft.AspNetCore.Components.Authorization
@using ReplayBrowser.Data
@using ReplayBrowser.Data.Models.Account
@using ReplayBrowser.Helpers
@using ReplayBrowser.Services
@using ReplayBrowser.Services.ReplayParser
@using Serilog
@inherits LayoutComponentBase
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject ReplayDbContext DbContext
@inject NavigationManager NavigationManager
@inject NoticeHelper NoticeHelper
@inject IHttpContextAccessor HttpContextAccessor
@inject IConfiguration Configuration

@code
{
    private System.Security.Claims.ClaimsPrincipal? _user;
    private Account? _account;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        _user = authState.User;
        if (_user?.Identity is null || !_user.Identity.IsAuthenticated)
            return;

        var guid = (Guid)AccountHelper.GetAccountGuid(authState)!;
        _account = DbContext.Accounts.FirstOrDefault(a => a.Guid == guid);
        if (_account is not null)
            return;

        Log.Error("Account {Guid} is authenticated but not found in the database", guid);
        NavigationManager.NavigateTo("account/redirect", new NavigationOptions()
        {
            ForceLoad = true
        });

    }
}

<div id="modal-root">

</div>

<div class="page">
    <header class="container my-5">
        @if (_user?.Identity is not null && _user.Identity.IsAuthenticated)
        {
            @if (_account is { Protected: true })
            {
                <div class="alert alert-warning" role="alert">
                    <h4 class="alert-heading">NOTICE</h4>
                    <p>Your account is set as protected. Your redaction settings were automatically set to true, in order to prevent harassment or similar. Contact the site operator to remove your protection status.</p>
                </div>
            }

            <p id="logged-in-text">Hello <strong>@_user.Claims.Single(c => c.Type == "name").Value!</strong></p>

            <a href="/account/logout" class="btn btn-primary" style="margin-right: 10px">Logout</a>
            <a href="/account/manage" class="btn btn-primary" style="margin-right: 10px">Manage</a>
            <a href="/favourites" class="btn btn-primary" style="margin-right: 10px">Favourites</a>
            <a href="/favorites/profiles" class="btn btn-primary" style="margin-right: 10px">Watched profiles</a>

            @if (_account?.IsAdmin ?? false)
            {
                <a href="/account/admin" class="btn btn-primary" style="margin-right: 10px">Admin</a>
                <a href="/account/admin/notices" class="btn btn-primary" style="margin-right: 10px">Manage notices</a>
            }
        }
        else
        {
            <a href="/account/login" class="btn btn-primary">Login via SS14</a>
        }

        <br/>
        <a href="/" class="btn btn-primary" style="margin-right: 10px; margin-top: 10px">Main page</a>
        <a href="/leaderboard" class="btn btn-primary" style="margin-right: 10px; margin-top: 10px">Leaderboard</a>
        <a href="/downloads" class="btn btn-primary" style="margin-right: 10px; margin-top: 10px">Current downloads</a>
        <a href="/changelog" class="btn btn-primary" style="margin-right: 10px; margin-top: 10px">Changelog</a>
    </header>
    <main class="container my-5">
        @foreach (var activeNotice in NoticeHelper.GetActiveNotices())
        {
            // See in cookies if we have already dismissed this notice
            var dismissed = HttpContextAccessor.HttpContext != null && HttpContextAccessor.HttpContext.Request.Cookies.ContainsKey($"dismissed-notice-{activeNotice.Id}");
            if (dismissed)
                continue;
            var markupString = new MarkupString(activeNotice.Message);

            <div class="alert alert-info" role="alert">
                <h4 class="alert-heading">@activeNotice.Title</h4>
                <p>@markupString</p>
                <button
                    type="button"
                    class="btn-close"
                    data-bs-dismiss="alert"
                    aria-label="Close"
                    onclick="document.cookie = `dismissed-notice-${@activeNotice.Id}=true; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/`;">
                </button>
            </div>
        }

        <p>Warning: Replays recorded before @ReplayParserService.CutOffDateTime.ToLocalTime().ToString("yyyy-MM-dd") (yyyy-MM-dd) are not supported and are not counted</p>

        <hr/>
        @Body
    </main>
</div>

<footer class="footer text-muted text-center">
    <div class="container">
        <p>Replay Browser is a project by Simyon and <a href="/contributors">contributors</a>. Source code available on <a href="https://github.com/Simyon264/ReplayBrowser">GitHub</a>.</p>
    </div>

    <div class="container">
        <p><a href="/contact">Contact</a> | <a href="/privacy">Privacy Policy</a> | <a href="@Configuration["Contact:Server"]" target="_blank">Discord Server</a></p>
    </div>
</footer>

<script>
    const modalRoot = document.getElementById('modal-root');
    const pageRoot = document.querySelector('.page');

    const modals = document.querySelectorAll('.modal');
    modals.forEach(modal => {
        modalRoot.appendChild(modal);
    });

    const observer = new MutationObserver(function(mutations) {
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => {
            modalRoot.appendChild(modal);
        });
    });
    observer.observe(pageRoot, { childList: true, subtree: true });

    function FavouriteReplay(replayId, reloadOnComplete = false) {
        // If we are not logged in, we set href to /account/login
        if (document.getElementById('logged-in-text') == null) {
            window.location.href = '/account/login'; // horrible code
            return;
        }

        fetch(`/api/replay/favourite/${replayId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        }).then(response => {
            if (response.ok) {
                // the response is just a boolean, true if its now favourited, false if its not
                response.json().then(isFavourited => {
                    let button = $(`#favorite-button-${replayId}`)

                    // we can just get the first child because the button only has one child
                    // either <i class="fas fa-star"></i> or <i class="far fa-star"></i>
                    let icon = button.children().first();
                    if (isFavourited) {
                        icon.removeClass('far');
                        icon.addClass('fas');
                        button.children().last().text('Remove from favourites');
                    } else {
                        icon.removeClass('fas');
                        icon.addClass('far');
                        button.children().last().text('Add to favorites');
                    }

                    if (reloadOnComplete) {
                        location.reload();
                    }
                })
            }
        });
    }

    async function loadTimeline(timelineElement, replayId, detailsContent) {
        let response = await fetch(`/api/Replay/${replayId}`);
        let data = await response.json();
        if (data.Events == null || data.Events.length == 0) {
            timelineElement.innerHTML = "<p class='card-text text-danger'>No events available.</p>";
            return;
        }

        const items = data.Events.map((event, index) => {
            const date = new Date(data.Date);
            date.setSeconds(date.getSeconds() + event.Time);

            // Deep loop through every property of the event and replace < and > with &lt; and &gt;
            // This is to prevent XSS attacks
            function escapeHtml(obj) {
                if (obj === null || obj === undefined) {
                    return obj;
                }
                if (typeof obj === 'string') {
                    return obj.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                } else if (typeof obj === 'object') {
                    for (const [key, value] of Object.entries(obj)) {
                        obj[key] = escapeHtml(value);
                    }
                }
                return obj;
            }

            event = escapeHtml(event);

            let content = "";
            switch (event.EventTypeString) {
                case "PlayerJoin":
                    content = `<p><strong>${event.Target.PlayerOocName}</strong> joined the round</p>`;
                    break;
                case "PlayerLeave":
                    content = `<p><strong>${event.Target.PlayerOocName}</strong> left the round</p>`;
                    break;

                case "GameRuleStarted":
                    content = `<p><strong>${event.Target}</strong> started</p>`;
                    break
                case "GameRuleEnded":
                    content = `<p><strong>${event.Target}</strong> ended</p>`;
                    break;
                case "RoundEnded":
                    content = `<p>Round ended</p>`;
                    break;

                case "ChatMessageSent":
                    switch (event.Type) {
                        case "Local":
                            content = `<p><strong>${event.Sender.PlayerIcName} (${event.Sender.PlayerOocName})</strong> said: ${event.Message}</p>`;
                            break;
                        case "Emotes":
                            content = `<p><strong>${event.Sender.PlayerIcName} (${event.Sender.PlayerOocName})</strong> <i>${event.Message}</i></p>`;
                            break;
                        case "Dead": // color purple
                            content = `<p style="color: rebeccapurple"><strong>${event.Sender.PlayerIcName} (${event.Sender.PlayerOocName})</strong> said: ${event.Message}</p>`;
                            break;
                        default:
                            content = `<p><strong>${event.Sender.PlayerIcName} (${event.Sender.PlayerOocName})</strong> said: ${event.Message}</p>`;
                            break;
                    }
                    break;

                case "AlertLevelChanged":
                    content = `<p>Alert level changed to <strong>${event.AlertLevel}</strong></p>`;
                    break;

                case "MobStateChanged":
                    if (event.OldStateString == "Alive" && event.NewStateString == "Dead") {
                        content = `<p><strong>${event.Target.PlayerIcName} (${event.Target.PlayerOocName})</strong> died</p>`;
                    } else if (event.OldStateString == "Alive" && event.NewStateString == "Crit") {
                        content = `<p><strong>${event.Target.PlayerIcName} (${event.Target.PlayerOocName})</strong> went into critical condition</p>`;
                    } else if (event.OldStateString == "Crit" && event.NewStateString == "Alive") {
                        content = `<p><strong>${event.Target.PlayerIcName} (${event.Target.PlayerOocName})</strong> was revived.</p>`;
                    } else if (event.OldStateString == "Crit" && event.NewStateString == "Dead") {
                        content = `<p><strong>${event.Target.PlayerIcName} (${event.Target.PlayerOocName})</strong> died</p>`;
                    } else if (event.OldStateString == "Dead" && event.NewStateString == "Crit") {
                        content = `<p><strong>${event.Target.PlayerIcName} (${event.Target.PlayerOocName})</strong> was revived</p>`;
                    } else {
                        content = `<p><strong>${event.Target.PlayerIcName} (${event.Target.PlayerOocName})</strong> changed state from <strong>${event.OldStateString}</strong> to <strong>${event.NewStateString}</strong></p>`;
                    }
                    break;

                default:
                    content = event.EventTypeString;
                    break;
            }

            return {
                id: index + 1,
                content: content,
                start: date,
                eventDetails: event,
            };
        });

        const dataset = new vis.DataSet(items);

        const options = {
            width: '100%',
            height: '800px',
            margin: {
                item: 20
            },
            editable: false,
            stack: true,
            zoomMin: 1000, // milliseconds
            zoomMax: 1000 * 60 * 60, // milliseconds
            showCurrentTime: false,
            showMajorLabels: true,
            showMinorLabels: true,
            xss: {disabled: true}
        };

        let timeline = new vis.Timeline(timelineElement, items, options);

        timeline.on('select', function (properties) {
            const selectedItem = dataset.get(properties.items[0]);
            if (selectedItem) {
                displayEventDetails(selectedItem.eventDetails);
            }
        });

        function displayEventDetails(event) {
            detailsContent.innerHTML = '';

            for (const [key, value] of Object.entries(event)) {
                if (typeof value === 'object' && value !== null) {
                    detailsContent.innerHTML += `<strong>${key}:</strong><pre>${JSON.stringify(value, null, 2)}</pre><br>`;
                } else {
                    detailsContent.innerHTML += `<strong>${key}:</strong> ${value}<br>`;
                }
            }
        }
    }

    // Once the modal is opened, we need to rerequest the round end players if they are null
    // This is because the modal doesn't load the data until it is opened
    async function loadDetails(playersElemn, endTextElement, replayId) {
        let response = await fetch(`/api/Replay/${replayId}`);
        let data = await response.json();

        let playerList = "";
        if (data.RoundParticipants == null || data.RoundParticipants.length == 0) {
            playersElemn.innerHTML = "<p class='card-text text-danger'>Replay is incomplete. No players available.</p>";
        } else {
            let players = data.RoundParticipants.flatMap(
                pc => pc.players.map(
                    pl => ({
                        ...pl,
                        PlayerGuid: pc.PlayerGuid,
                        username: pc.username
                    })
                )
            )
            // Sort the players so that antags are at the top
            players.sort((a, b) => {
                if (a.AntagPrototypes.length > 0 && b.AntagPrototypes.length == 0) {
                    return -1;
                } else if (a.AntagPrototypes.length == 0 && b.AntagPrototypes.length > 0) {
                    return 1;
                }
                return 0;
            });

            playersElemn.innerHTML = players.map(player => {
                let job = "Unknown";
                if (player.JobPrototypes.length > 0) {
                    job = player.JobPrototypes[0];
                }
                let playerText = `<a href="/player/${player.PlayerGuid}"><span style="color: gray">${player.Username}</span></a> was <bold>${player.PlayerIcName}</bold> playing role of <span style="color: orange"><bold>${job}</bold></span>`;
                if (player.AntagPrototypes.length > 0) {
                    playerText = `<a href="/player/${player.PlayerGuid}"><span style="color: red">${player.Username}</span></a> was <span style="color:red"><bold>${player.PlayerIcName}</bold></span> playing role of <span style="color: orange"><bold>${job}</bold></span>`;
                }
                // Need to show the guid as well
                playerText += `<br><span style="color: gray;font-size: x-small;"> ${player.PlayerGuid}</span>`;
                return playerText;
            }).join("<br>\n");
        }

        if (!data.RoundEndText || data.RoundEndText.trim() == "") {
            endTextElement.innerHTML = "No round end text available.";
        } else {
            const colorTagPattern = new RegExp("\\[color=(.*?)\\](.*?)\\[/color\\]", "g");
            const colorTagReplacement = "<span style=\"color:$1\">$2</span>";

            const boldTagPattern =  new RegExp("\\[bold\\](.*?)\\[/bold\\]", "g");
            const boldTagReplacement = "<strong>$1</strong>";

            endTextElement.innerHTML = data.RoundEndText.trim()
                .replaceAll(colorTagPattern, colorTagReplacement)
                .replaceAll("\n", "<br>")
                .replaceAll(boldTagPattern, boldTagReplacement);
        }
    }

</script>